// Generated using `moon info`, DON'T EDIT IT
package "mizchi/ui/vdom"

import(
  "mizchi/js/browser/dom"
  "mizchi/js/core"
)

// Values
pub fn[H] a(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] alt(String) -> (String, AttrValue[H])

pub fn apply_patches(Array[Patch[(@core.Any) -> Unit]]) -> Unit

pub fn[H] attr(String, String) -> (String, AttrValue[H])

pub fn[H] attr_bool(String, Bool) -> (String, AttrValue[H])

pub fn[H] attr_num(String, Int) -> (String, AttrValue[H])

pub fn[H] br() -> VNode[H]

pub fn[H] button(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] checked(Bool) -> (String, AttrValue[H])

pub fn[H] class_name(String) -> (String, AttrValue[H])

pub fn[T] clear_context(Context[T]) -> Unit

pub fn[H] compare_attr_value(AttrValue[H], AttrValue[H]) -> Bool

pub fn[H] compare_props(Array[(String, AttrValue[H])], Array[(String, AttrValue[H])]) -> Bool

pub fn[H] component(() -> VNode[H], String?, HooksState) -> VNode[H]

pub fn[H, P] component_with_props((P) -> VNode[H], P, String?, HooksState) -> VNode[H]

pub fn console_logger(String) -> Unit

pub fn[T] create_context(T) -> Context[T]

pub fn create_js_storage() -> ContextStorage

pub fn create_memory_storage() -> ContextStorage

pub fn[H] data_(String, String) -> (String, AttrValue[H])

pub fn[H] diff(VNode[H]?, VNode[H]?, @dom.Node?, @dom.Node?) -> Array[Patch[H]]

pub fn[H] disabled(Bool) -> (String, AttrValue[H])

pub fn[H] div(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] el(String, Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] el_key(String, Array[(String, AttrValue[H])], Array[VNode[H]], String) -> VNode[H]

pub fn[H] empty() -> VNode[H]

pub fn extract_state_from_html(String) -> String?

pub fn[H] for_(String) -> (String, AttrValue[H])

pub fn[H] form(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] fragment(Array[VNode[H]]) -> VNode[H]

pub fn[T] get_context(Context[T]) -> T

pub fn[H] h1(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] h2(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] h3(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] h4(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] h5(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] h6(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] hr() -> VNode[H]

pub fn[H] href(String) -> (String, AttrValue[H])

pub fn[H] id(String) -> (String, AttrValue[H])

pub fn[H] img(Array[(String, AttrValue[H])]) -> VNode[H]

pub fn[H] input(Array[(String, AttrValue[H])]) -> VNode[H]

pub fn[H] label(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] li(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] max_length(Int) -> (String, AttrValue[H])

pub fn[H] name(String) -> (String, AttrValue[H])

pub fn[H] ol(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] on_blur(H) -> (String, AttrValue[H])

pub fn[H] on_change(H) -> (String, AttrValue[H])

pub fn[H] on_click(H) -> (String, AttrValue[H])

pub fn[H] on_focus(H) -> (String, AttrValue[H])

pub fn[H] on_input(H) -> (String, AttrValue[H])

pub fn[H] on_key_down(H) -> (String, AttrValue[H])

pub fn[H] on_key_up(H) -> (String, AttrValue[H])

pub fn[H] on_mouse_enter(H) -> (String, AttrValue[H])

pub fn[H] on_mouse_leave(H) -> (String, AttrValue[H])

pub fn[H] on_submit(H) -> (String, AttrValue[H])

pub fn[H] p(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] placeholder(String) -> (String, AttrValue[H])

pub fn[H] props() -> Array[(String, AttrValue[H])]

pub fn[H] readonly_(Bool) -> (String, AttrValue[H])

pub fn[H] render_component(VNode[H]) -> VNode[H]

pub fn[H] render_component_with_effects(VNode[H]) -> VNode[H]

pub fn render_to_string(VNode[(@core.Any) -> Unit]) -> String

pub fn render_to_string_with_state(VNode[(@core.Any) -> Unit], HooksState) -> String

pub fn[H] required(Bool) -> (String, AttrValue[H])

pub fn[T] set_context(Context[T], T) -> Unit

pub fn set_current_hooks_state(HooksState?) -> Unit

pub fn silent_logger(String) -> Unit

pub fn[H] span(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] src(String) -> (String, AttrValue[H])

pub fn[H] style(Array[(String, String)]) -> (String, AttrValue[H])

pub fn[H] tab_index(Int) -> (String, AttrValue[H])

pub fn[H] text(String) -> VNode[H]

pub fn[H] textarea(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[H] title(String) -> (String, AttrValue[H])

pub fn[H] type_(String) -> (String, AttrValue[H])

pub fn[H] ul(Array[(String, AttrValue[H])], Array[VNode[H]]) -> VNode[H]

pub fn[T] use_callback(T, Array[@core.Any]?) -> T

pub fn use_effect(() -> (() -> Unit)?, Array[@core.Any]?) -> Unit

pub fn[T] use_memo(() -> T, Array[@core.Any]?) -> T

pub fn[T] use_ref(T?) -> MutRef[T]

pub fn[T] use_state(T) -> (T, (T) -> Unit)

pub fn[H] value(String) -> (String, AttrValue[H])

// Errors

// Types and methods
pub enum AttrValue[H] {
  Str(String)
  Num(Int)
  Bool(Bool)
  Handler(H)
  StyleObj(Array[(String, String)])
}

pub struct ComponentNode[H] {
  render : () -> VNode[H]
  key : String?
  hooks_state : HooksState
}

pub struct Context[T] {
  id : Int
  default_value : T
}

pub struct ContextStorage {
  get_value : (Int) -> @core.Any?
  set_value : (Int, @core.Any) -> Unit
  delete_value : (Int) -> Unit
  get_next_id : () -> Int
}

pub struct DomRenderer {
  container : @dom.Element
  mut root_vnode : VNode[(@core.Any) -> Unit]?
  mut root_node : @dom.Node?
  logger : (String) -> Unit
}
pub fn DomRenderer::hydrate(Self, VNode[(@core.Any) -> Unit]) -> Unit
pub fn DomRenderer::hydrate_with_state(Self, VNode[(@core.Any) -> Unit], HooksState) -> Unit
pub fn DomRenderer::new(@dom.Element) -> Self
pub fn DomRenderer::new_with_logger(@dom.Element, (String) -> Unit) -> Self
pub fn DomRenderer::render(Self, VNode[(@core.Any) -> Unit]) -> Unit

pub struct Effect {
  cleanup : (() -> Unit)?
  effect : () -> (() -> Unit)?
  _deps : Array[@core.Any]?
}

pub struct ElementNode[H] {
  tag : String
  props : Array[(String, AttrValue[H])]
  children : Array[VNode[H]]
  key : String?
}

pub struct HooksState {
  hooks : Array[@core.Any]
  mut current_index : Int
  mut effects : Array[Effect]
}
pub fn HooksState::from_json(String) -> Self
pub fn HooksState::new() -> Self
pub fn HooksState::reset_index(Self) -> Unit
pub fn HooksState::restore_from_json(Self, String) -> Unit
pub fn HooksState::run_effects(Self) -> Unit
pub fn HooksState::serialize_js(Self) -> String

pub struct MutRef[T] {
  mut value : T?
}
pub fn[T] MutRef::get(Self[T]) -> T?
pub fn[T] MutRef::new(T?) -> Self[T]
pub fn[T] MutRef::set(Self[T], T?) -> Unit

type Patch[H]

pub enum VNode[H] {
  Element(ElementNode[H])
  Text(String)
  Component(ComponentNode[H])
  Fragment(Array[VNode[H]])
  Empty
}
pub fn[H] VNode::debug_string(Self[H]) -> String
pub fn[H] VNode::get_key(Self[H]) -> String?
pub fn[H] VNode::is_empty(Self[H]) -> Bool

// Type aliases
pub type Component0[H] = () -> VNode[H]

pub type Component1[H, P] = (P) -> VNode[H]

pub type EventHandler = (@core.Any) -> Unit

pub type JSAttrValue = AttrValue[(@core.Any) -> Unit]

pub type JSElementNode = ElementNode[(@core.Any) -> Unit]

pub type JSHandler = (@core.Any) -> Unit

pub type JSProps = Array[(String, AttrValue[(@core.Any) -> Unit])]

pub type JSVNode = VNode[(@core.Any) -> Unit]

pub type Logger = (String) -> Unit

pub type Props[H] = Array[(String, AttrValue[H])]

// Traits

