# Virtual DOM vs Signals ベンチマーク比較

## 概要

両アプローチの性能特性を比較。MoonBit ターゲット: JavaScript

## ベンチマーク結果

### 1. 基本操作

| 操作 | Virtual DOM | Signals | 備考 |
|------|-------------|---------|------|
| 状態作成 | text: 0.01µs | Signal::new: 0.01µs | 同等 |
| 状態読み取り | - | Signal::get: 0.01µs | VDOMは直接参照 |
| 状態更新 | - | Signal::set: 0.00µs | VDOMは再レンダリング |

### 2. ツリー作成

| 操作 | Virtual DOM | Signals | 備考 |
|------|-------------|---------|------|
| 空div | 0.01µs | - | |
| div+text | 0.01µs | - | |
| 3 children | 0.02µs | - | |
| ネスト2層 | 0.02µs | - | |
| ネスト3層 | 0.03µs | - | |
| 複雑ツリー | 0.09µs | - | nav+header+main |
| 10アイテムリスト | 0.08µs | - | |

### 3. リアクティブ更新

| 操作 | Virtual DOM | Signals | 備考 |
|------|-------------|---------|------|
| effect作成+破棄 | - | 0.05µs | |
| effect再実行 | - | 0.01µs | **高速** |
| memo作成 | - | 0.03µs | |
| memoキャッシュ読み | - | 0.04µs | |
| memo再計算 | - | 0.02µs | |
| batch 3更新 | - | 0.01µs | |

### 4. 依存グラフ

| パターン | Virtual DOM | Signals | 備考 |
|----------|-------------|---------|------|
| 3段派生チェーン | - | 0.04µs | A→B→C→D |
| ダイアモンド依存 | - | 0.09µs | A→B,C→D |
| 5 effects/1 signal | - | 0.12µs | ファンアウト |
| 10段派生チェーン | - | 0.25µs | 深いチェーン |

### 5. 大規模ベンチマーク

| 操作 | Virtual DOM | Signals | 差分 |
|------|-------------|---------|------|
| 100アイテム作成 | 1.93µs | 0.91µs | **Signals 2.1x 高速** |
| 1000アイテム作成 | 25.82µs | 10.92µs | **Signals 2.4x 高速** |
| ネスト10層 | 0.10µs | 0.25µs | VDOM 2.5x 高速 |
| 100 divs + props | 5.22µs | - | |
| fragment 100 children | 1.67µs | - | |
| 100 card components | 7.79µs | - | |
| 100 memos 更新 | - | 14.29µs | wide dependency |
| 100 effects/1 signal | - | 12.98µs | fan-out pattern |

### 6. バッチ処理の効果

| 操作 | 時間 | 備考 |
|------|------|------|
| batch 100 signals | 0.80µs | 一括更新 |
| unbatched 100 signals | 33.59µs | 個別更新 |
| **差分** | **42x** | **バッチが圧倒的に高速** |

## 分析

### Virtual DOM の特徴

**長所:**
- ツリー構造の作成が高速 (0.01-0.09µs)
- 深いネスト構造に強い (10層: 0.10µs)
- 宣言的なUI記述
- SSRとの親和性が高い

**短所:**
- 更新時に差分計算（reconcile）が必要
- 大きなツリーでは O(tree size) の計算コスト
- 部分更新でも全体を走査

### Signals の特徴

**長所:**
- 更新が O(1) - 変更された部分のみ更新
- effect再実行: 0.01µs（非常に高速）
- バッチ処理で42倍高速化
- 1000シグナル作成でもVDOMより高速

**短所:**
- 深いネスト構造はVDOMより遅い
- メモリに依存グラフを保持
- デバッグが複雑になりやすい

### バッチ処理の重要性

100個のシグナルを更新する場合:
- **バッチあり**: 0.80µs（エフェクトは1回だけ実行）
- **バッチなし**: 33.59µs（エフェクトが100回実行）

→ **42倍の性能差**。複数シグナルを更新する場合は必ず`batch()`を使用すべき。

## ユースケース別推奨

| ユースケース | 推奨 | 理由 |
|--------------|------|------|
| 静的コンテンツ多め | VDOM | 初期レンダリングが高速 |
| 頻繁な状態更新 | Signals | 更新が O(1) |
| 大きなリスト | Signals | 1000件でも10.92µs |
| フォーム入力 | Signals | リアルタイム反映が高速 |
| SSR必須 | VDOM | 文字列生成が容易 |
| アニメーション | Signals | 高頻度更新に強い |
| 深いネスト構造 | VDOM | 10層でも0.10µs |
| 複数状態の同時更新 | Signals + batch | 42x高速化 |

## 結論

両アプローチは補完的な関係にある：

- **VDOM**: 構造の宣言と初期レンダリングに強い
- **Signals**: 状態更新と部分更新に強い（特にバッチ処理時）

ハイブリッドアプローチ（VDOMで構造、Signalsで状態管理）も検討の価値あり。
