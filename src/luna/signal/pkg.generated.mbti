// Generated using `moon info`, DON'T EDIT IT
package "mizchi/luna/luna/signal"

// Values
pub fn all(Array[Signal[Bool]]) -> () -> Bool

pub fn any(Array[Signal[Bool]]) -> () -> Bool

pub fn[T] batch(() -> T) -> T

pub fn batch_end() -> Unit

pub fn batch_start() -> Unit

pub fn[A, B, R] combine2(Signal[A], Signal[B], (A, B) -> R) -> () -> R

pub fn[A, B, C, R] combine3(Signal[A], Signal[B], Signal[C], (A, B, C) -> R) -> () -> R

pub fn[A, B, C, D, R] combine4(Signal[A], Signal[B], Signal[C], Signal[D], (A, B, C, D) -> R) -> () -> R

pub fn[T] computed(() -> T) -> () -> T

pub fn[T] create_context(T) -> Context[T]

pub fn[T] create_root((() -> Unit) -> T) -> T

pub fn[T] create_root_with_dispose(() -> T) -> (T, () -> Unit)

pub fn[T] deferred() -> (Resource[T], (T) -> Unit, (String) -> Unit)

pub fn effect(() -> Unit) -> () -> Unit

pub fn effect_once(() -> Unit) -> Unit

pub fn effect_when(() -> Bool, () -> Unit) -> () -> Unit

pub fn[T] flatten(Signal[Signal[T]]) -> () -> T

pub fn get_current_subscriber() -> EffectRunner?

pub fn get_owner() -> Owner?

pub fn has_owner() -> Bool

pub fn is_batching() -> Bool

pub fn[T] memo(() -> T) -> () -> T

pub fn new_effect_id() -> Int

pub fn[T] on(Signal[T], (T) -> Unit) -> () -> Unit

pub fn on_cleanup(() -> Unit) -> Unit

pub fn[T] on_immediate(Signal[T], (T) -> Unit) -> () -> Unit

pub fn on_mount(() -> Unit) -> Unit

pub fn[T] previous(Signal[T]) -> () -> T?

pub fn[T] previous_with_initial(Signal[T], T) -> () -> T

pub fn[T, R] provide(Context[T], T, () -> R) -> R

pub fn register_disposer(() -> Unit) -> Unit

pub fn register_owner_cleanup(() -> Unit) -> Unit

pub fn render_effect(() -> Unit) -> () -> Unit

pub fn[T] resource(((T) -> Unit, (String) -> Unit) -> Unit) -> Resource[T]

pub fn[T] resource_rejected(String) -> Resource[T]

pub fn[T] resource_resolved(T) -> Resource[T]

pub fn[T] run_with_cleanup_tracking(Array[() -> Unit], () -> T) -> T

pub fn[T] run_with_owner(Owner, () -> T) -> T

pub fn[T] run_with_subscriber(EffectRunner, () -> T) -> T

pub fn schedule_effect(EffectRunner) -> Unit

pub fn[T] select(Signal[Array[T]], Signal[Int]) -> () -> T?

pub fn set_current_cleanups(Array[() -> Unit]?) -> Array[() -> Unit]?

pub fn[T] signal(T) -> Signal[T]

pub fn[T] switch_(Signal[Bool], Signal[T], Signal[T]) -> () -> T

pub fn[T] untracked(() -> T) -> T

pub fn[T] use_context(Context[T]) -> T

pub fn[T : Eq] watch(() -> T, (T, T) -> Unit) -> () -> Unit

pub fn[T : Eq] watch_immediate(() -> T, (T, T?) -> Unit) -> () -> Unit

// Errors

// Types and methods
pub enum AsyncState[T] {
  Pending
  Success(T)
  Failure(String)
}
pub fn[T] AsyncState::error(Self[T]) -> String?
pub fn[T] AsyncState::is_failure(Self[T]) -> Bool
pub fn[T] AsyncState::is_pending(Self[T]) -> Bool
pub fn[T] AsyncState::is_success(Self[T]) -> Bool
pub fn[T] AsyncState::value(Self[T]) -> T?

pub struct Context[T] {
  id : Int
  default_value : () -> T
  providers : Array[(Int, () -> T)]
}

pub struct EffectRunner {
  id : Int
  run : () -> Unit
}

pub struct Lens[S, A] {
  get : (S) -> A
  set : (S, A) -> S
}
pub fn[S, A] Lens::new((S) -> A, (S, A) -> S) -> Self[S, A]

pub struct LensStore[T] {
  source : Signal[T]
}
pub fn[T, A : Eq] LensStore::focus(Self[T], Lens[T, A]) -> (Signal[A], (A) -> Unit)
pub fn[T] LensStore::new(T) -> Self[T]
pub fn[T] LensStore::snapshot(Self[T]) -> T
pub fn[T] LensStore::update(Self[T], (T) -> T) -> Unit

pub struct Owner {
  id : Int
  parent : Owner?
  children : Array[Owner]
  cleanups : Array[() -> Unit]
  disposers : Array[() -> Unit]
  mut disposed : Bool
}
pub fn Owner::dispose(Self) -> Unit
pub fn Owner::new(Self?) -> Self

pub struct Resource[T] {
  state : Signal[AsyncState[T]]
  // private fields
}
pub fn[T] Resource::error(Self[T]) -> String?
pub fn[T] Resource::get(Self[T]) -> AsyncState[T]
pub fn[T] Resource::is_failure(Self[T]) -> Bool
pub fn[T] Resource::is_pending(Self[T]) -> Bool
pub fn[T] Resource::is_success(Self[T]) -> Bool
pub fn[T] Resource::peek(Self[T]) -> AsyncState[T]
pub fn[T] Resource::refetch(Self[T]) -> Unit
pub fn[T] Resource::value(Self[T]) -> T?

pub struct Signal[T] {
  mut value : T
  subscribers : Array[EffectRunner]
}
pub fn[T] Signal::clear_subscribers(Self[T]) -> Unit
pub fn[T] Signal::filter(Self[T], (T) -> Bool) -> Self[T?]
pub fn[T, U] Signal::filter_map(Self[T], (T) -> U?) -> Self[U?]
pub fn[T] Signal::get(Self[T]) -> T
pub fn[T, U] Signal::map(Self[T], (T) -> U) -> () -> U
pub fn[T] Signal::new(T) -> Self[T]
pub fn[T] Signal::peek(Self[T]) -> T
pub fn[T] Signal::remove_subscriber(Self[T], Int) -> Unit
pub fn[T] Signal::set(Self[T], T) -> Unit
pub fn[T] Signal::subscriber_count(Self[T]) -> Int
pub fn[T] Signal::to_getter(Self[T]) -> () -> T
pub fn[T] Signal::update(Self[T], (T) -> T) -> Unit

pub struct SplitStore2[A, B] {
  field1 : Signal[A]
  field2 : Signal[B]
}
pub fn[A, B] SplitStore2::new(A, B) -> Self[A, B]

pub struct SplitStore3[A, B, C] {
  field1 : Signal[A]
  field2 : Signal[B]
  field3 : Signal[C]
}
pub fn[A, B, C] SplitStore3::new(A, B, C) -> Self[A, B, C]

// Type aliases

// Traits
pub trait Snapshot {
  snapshot(Self) -> Self
}

