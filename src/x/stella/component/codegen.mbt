// Web Component Code Generation
// Generates JavaScript code for Web Components

///|
/// Generate the full Web Component JavaScript code
pub fn generate_component_js(
  meta : ComponentMeta,
  /// Path to the MoonBit compiled module (relative)
  module_path : String,
) -> String {
  let sb = StringBuilder::new()

  // Imports
  sb.write_string("// Generated by stella/component\n")
  sb.write_string("import { Signal, effect } from '@luna_ui/wcr';\n")
  sb.write_string("import * as mod from '")
  sb.write_string(module_path)
  sb.write_string("';\n\n")

  // Stylesheet
  if meta.styles.length() > 0 && meta.shadow != None {
    sb.write_string("const sheet = new CSSStyleSheet();\n")
    sb.write_string("sheet.replaceSync(`")
    sb.write_string(escape_template_literal(meta.styles))
    sb.write_string("`);\n\n")
  }

  // Class definition
  sb.write_string("class ")
  sb.write_string(tag_to_class_name(meta.tag))
  sb.write_string(" extends HTMLElement {\n")

  // observedAttributes
  sb.write_string("  static observedAttributes = [")
  for i, attr in meta.attributes {
    if i > 0 {
      sb.write_string(", ")
    }
    sb.write_string("'")
    sb.write_string(attr.name)
    sb.write_string("'")
  }
  sb.write_string("];\n\n")

  // Private fields
  sb.write_string("  #props = {\n")
  for i, attr in meta.attributes {
    if i > 0 {
      sb.write_string(",\n")
    }
    sb.write_string("    ")
    sb.write_string(attr_to_js_key(attr.name))
    sb.write_string(": new Signal(")
    sb.write_string(attr_default_to_js(attr.attr_type))
    sb.write_string(")")
  }
  sb.write_string("\n  };\n")
  sb.write_string("  #dispose = null;\n")
  sb.write_string("  #connected = false;\n\n")

  // connectedCallback
  sb.write_string("  connectedCallback() {\n")
  sb.write_string("    this.#connected = true;\n")
  sb.write_string("    this.#syncAttributes();\n\n")

  // Shadow DOM setup
  match meta.shadow {
    Open => {
      sb.write_string(
        "    const shadow = this.shadowRoot ?? this.attachShadow({ mode: 'open' });\n",
      )
      if meta.styles.length() > 0 {
        sb.write_string("    shadow.adoptedStyleSheets = [sheet];\n")
      }
    }
    Closed => {
      sb.write_string(
        "    const shadow = this.attachShadow({ mode: 'closed' });\n",
      )
      if meta.styles.length() > 0 {
        sb.write_string("    shadow.adoptedStyleSheets = [sheet];\n")
      }
    }
    None => sb.write_string("    const shadow = this;\n")
  }

  // Template rendering for empty elements
  sb.write_string("\n    if (!this.shadowRoot && mod.template) {\n")
  sb.write_string(
    "      shadow.innerHTML = mod.template(this.#getSnapshot());\n",
  )
  sb.write_string("    }\n\n")

  // Setup call
  sb.write_string("    this.#dispose = mod.setup({\n")
  sb.write_string("      element: this,\n")
  sb.write_string("      shadow,\n")
  sb.write_string("      props: this.#props,\n")
  sb.write_string("    });\n")
  sb.write_string("  }\n\n")

  // disconnectedCallback
  sb.write_string("  disconnectedCallback() {\n")
  sb.write_string("    this.#connected = false;\n")
  sb.write_string("    this.#dispose?.();\n")
  sb.write_string("    this.#dispose = null;\n")
  sb.write_string("  }\n\n")

  // attributeChangedCallback
  sb.write_string("  attributeChangedCallback(name, _, newVal) {\n")
  sb.write_string("    if (!this.#connected) return;\n")
  sb.write_string("    switch (name) {\n")
  for attr in meta.attributes {
    sb.write_string("      case '")
    sb.write_string(attr.name)
    sb.write_string("':\n")
    sb.write_string("        this.#props.")
    sb.write_string(attr_to_js_key(attr.name))
    sb.write_string(".set(")
    sb.write_string(attr_parse_expr(attr))
    sb.write_string(");\n")
    sb.write_string("        break;\n")
  }
  sb.write_string("    }\n")
  sb.write_string("  }\n\n")

  // #syncAttributes
  sb.write_string("  #syncAttributes() {\n")
  for attr in meta.attributes {
    sb.write_string("    this.#props.")
    sb.write_string(attr_to_js_key(attr.name))
    sb.write_string(".set(")
    sb.write_string(attr_sync_expr(attr))
    sb.write_string(");\n")
  }
  sb.write_string("  }\n\n")

  // #getSnapshot
  sb.write_string("  #getSnapshot() {\n")
  sb.write_string("    return {\n")
  for i, attr in meta.attributes {
    if i > 0 {
      sb.write_string(",\n")
    }
    sb.write_string("      ")
    sb.write_string(attr_to_js_key(attr.name))
    sb.write_string(": this.#props.")
    sb.write_string(attr_to_js_key(attr.name))
    sb.write_string(".get()")
  }
  sb.write_string("\n    };\n")
  sb.write_string("  }\n")
  sb.write_string("}\n\n")

  // Register
  sb.write_string("customElements.define('")
  sb.write_string(meta.tag)
  sb.write_string("', ")
  sb.write_string(tag_to_class_name(meta.tag))
  sb.write_string(");\n")
  sb.to_string()
}

// =============================================================================
// Helper Functions
// =============================================================================

///|
/// Convert kebab-case tag to PascalCase class name
fn tag_to_class_name(tag : String) -> String {
  let sb = StringBuilder::new()
  let mut capitalize_next = true
  for c in tag {
    if c == '-' {
      capitalize_next = true
    } else if capitalize_next {
      sb.write_char(char_to_upper(c))
      capitalize_next = false
    } else {
      sb.write_char(c)
    }
  }
  sb.to_string()
}

///|
/// Convert kebab-case to camelCase
fn attr_to_js_key(name : String) -> String {
  let sb = StringBuilder::new()
  let mut capitalize_next = false
  for c in name {
    if c == '-' {
      capitalize_next = true
    } else if capitalize_next {
      sb.write_char(char_to_upper(c))
      capitalize_next = false
    } else {
      sb.write_char(c)
    }
  }
  sb.to_string()
}

///|
/// Convert lowercase char to uppercase
fn char_to_upper(c : Char) -> Char {
  let code = c.to_int()
  // a-z: 97-122 -> A-Z: 65-90
  if code >= 97 && code <= 122 {
    (code - 32).unsafe_to_char()
  } else {
    c
  }
}

///|
/// Get default value as JS expression
fn attr_default_to_js(attr_type : AttrType) -> String {
  match attr_type {
    String(default~) => "'" + escape_js_string(default) + "'"
    Int(default~) => default.to_string()
    Float(default~) => default.to_string()
    Bool(default~) => if default { "true" } else { "false" }
  }
}

///|
/// Generate parse expression for attributeChangedCallback
fn attr_parse_expr(attr : AttrDef) -> String {
  match attr.attr_type {
    String(_) => "newVal ?? ''"
    Int(default~) => "parseInt(newVal ?? '" + default.to_string() + "', 10)"
    Float(default~) => "parseFloat(newVal ?? '" + default.to_string() + "')"
    Bool(_) => "newVal !== null"
  }
}

///|
/// Generate sync expression for initial attribute read
fn attr_sync_expr(attr : AttrDef) -> String {
  match attr.attr_type {
    String(default~) =>
      "this.getAttribute('" +
      attr.name +
      "') ?? '" +
      escape_js_string(default) +
      "'"
    Int(default~) =>
      "parseInt(this.getAttribute('" +
      attr.name +
      "') ?? '" +
      default.to_string() +
      "', 10)"
    Float(default~) =>
      "parseFloat(this.getAttribute('" +
      attr.name +
      "') ?? '" +
      default.to_string() +
      "')"
    Bool(_) => "this.hasAttribute('" + attr.name + "')"
  }
}

///|
/// Escape string for JS string literal
fn escape_js_string(s : String) -> String {
  let sb = StringBuilder::new()
  for c in s {
    match c {
      '\'' => sb.write_string("\\'")
      '\\' => sb.write_string("\\\\")
      '\n' => sb.write_string("\\n")
      '\r' => sb.write_string("\\r")
      '\t' => sb.write_string("\\t")
      _ => sb.write_char(c)
    }
  }
  sb.to_string()
}

///|
/// Escape string for template literal
fn escape_template_literal(s : String) -> String {
  let sb = StringBuilder::new()
  for c in s {
    match c {
      '`' => sb.write_string("\\`")
      '$' => sb.write_string("\\$")
      '\\' => sb.write_string("\\\\")
      _ => sb.write_char(c)
    }
  }
  sb.to_string()
}
