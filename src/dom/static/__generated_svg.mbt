// =============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
// Generated by: scripts/generate_dom_elements.ts
// =============================================================================

///| SVG element factories for server-side rendering

///|

///| SVG elements for SSR. Namespace is handled during HTML rendering.

// =============================================================================

// SVG Element factories

// =============================================================================

///|
/// Create an SVG element
pub fn svg(
  width? : String,
  height? : String,
  viewBox? : String,
  xmlns? : String,
  fill? : String,
  stroke? : String,
  role? : String,
  aria_label? : String,
  aria_labelledby? : String,
  aria_describedby? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if width is Some(v) {
    props.push(("width", static_attr(v)))
  }
  if height is Some(v) {
    props.push(("height", static_attr(v)))
  }
  if viewBox is Some(v) {
    props.push(("viewBox", static_attr(v)))
  }
  if xmlns is Some(v) {
    props.push(("xmlns", static_attr(v)))
  }
  if fill is Some(v) {
    props.push(("fill", static_attr(v)))
  }
  if stroke is Some(v) {
    props.push(("stroke", static_attr(v)))
  }
  if role is Some(v) {
    props.push(("role", static_attr(v)))
  }
  if aria_label is Some(v) {
    props.push(("aria-label", static_attr(v)))
  }
  if aria_labelledby is Some(v) {
    props.push(("aria-labelledby", static_attr(v)))
  }
  if aria_describedby is Some(v) {
    props.push(("aria-describedby", static_attr(v)))
  }
  create_svg_element("svg", props, children)
}

///|
/// Create an SVG title element for accessibility
pub fn svg_title(
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  create_svg_element("title", props, children)
}

///|
/// Create an SVG desc element for accessibility
pub fn svg_desc(
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  create_svg_element("desc", props, children)
}

///|
/// Create an SVG group element
pub fn svg_g(
  transform? : String,
  fill? : String,
  stroke? : String,
  opacity? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if transform is Some(v) {
    props.push(("transform", static_attr(v)))
  }
  if fill is Some(v) {
    props.push(("fill", static_attr(v)))
  }
  if stroke is Some(v) {
    props.push(("stroke", static_attr(v)))
  }
  if opacity is Some(v) {
    props.push(("opacity", static_attr(v)))
  }
  create_svg_element("g", props, children)
}

///|
/// Create an SVG defs element
pub fn svg_defs(
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  create_svg_element("defs", props, children)
}

///|
/// Create an SVG symbol element
pub fn svg_symbol(
  viewBox? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if viewBox is Some(v) {
    props.push(("viewBox", static_attr(v)))
  }
  create_svg_element("symbol", props, children)
}

///|
/// Create an SVG use element
pub fn svg_use(
  href? : String,
  x? : String,
  y? : String,
  width? : String,
  height? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if href is Some(v) {
    props.push(("href", static_attr(v)))
  }
  if x is Some(v) {
    props.push(("x", static_attr(v)))
  }
  if y is Some(v) {
    props.push(("y", static_attr(v)))
  }
  if width is Some(v) {
    props.push(("width", static_attr(v)))
  }
  if height is Some(v) {
    props.push(("height", static_attr(v)))
  }
  create_svg_element("use", props, [])
}

///|
/// Create an SVG rect element
pub fn svg_rect(
  x? : String,
  y? : String,
  width? : String,
  height? : String,
  rx? : String,
  ry? : String,
  fill? : String,
  stroke? : String,
  stroke_width? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if x is Some(v) {
    props.push(("x", static_attr(v)))
  }
  if y is Some(v) {
    props.push(("y", static_attr(v)))
  }
  if width is Some(v) {
    props.push(("width", static_attr(v)))
  }
  if height is Some(v) {
    props.push(("height", static_attr(v)))
  }
  if rx is Some(v) {
    props.push(("rx", static_attr(v)))
  }
  if ry is Some(v) {
    props.push(("ry", static_attr(v)))
  }
  if fill is Some(v) {
    props.push(("fill", static_attr(v)))
  }
  if stroke is Some(v) {
    props.push(("stroke", static_attr(v)))
  }
  if stroke_width is Some(v) {
    props.push(("stroke-width", static_attr(v)))
  }
  create_svg_element("rect", props, [])
}

///|
/// Create an SVG circle element
pub fn svg_circle(
  cx? : String,
  cy? : String,
  r? : String,
  fill? : String,
  stroke? : String,
  stroke_width? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if cx is Some(v) {
    props.push(("cx", static_attr(v)))
  }
  if cy is Some(v) {
    props.push(("cy", static_attr(v)))
  }
  if r is Some(v) {
    props.push(("r", static_attr(v)))
  }
  if fill is Some(v) {
    props.push(("fill", static_attr(v)))
  }
  if stroke is Some(v) {
    props.push(("stroke", static_attr(v)))
  }
  if stroke_width is Some(v) {
    props.push(("stroke-width", static_attr(v)))
  }
  create_svg_element("circle", props, [])
}

///|
/// Create an SVG ellipse element
pub fn svg_ellipse(
  cx? : String,
  cy? : String,
  rx? : String,
  ry? : String,
  fill? : String,
  stroke? : String,
  stroke_width? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if cx is Some(v) {
    props.push(("cx", static_attr(v)))
  }
  if cy is Some(v) {
    props.push(("cy", static_attr(v)))
  }
  if rx is Some(v) {
    props.push(("rx", static_attr(v)))
  }
  if ry is Some(v) {
    props.push(("ry", static_attr(v)))
  }
  if fill is Some(v) {
    props.push(("fill", static_attr(v)))
  }
  if stroke is Some(v) {
    props.push(("stroke", static_attr(v)))
  }
  if stroke_width is Some(v) {
    props.push(("stroke-width", static_attr(v)))
  }
  create_svg_element("ellipse", props, [])
}

///|
/// Create an SVG line element
pub fn svg_line(
  x1? : String,
  y1? : String,
  x2? : String,
  y2? : String,
  stroke? : String,
  stroke_width? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if x1 is Some(v) {
    props.push(("x1", static_attr(v)))
  }
  if y1 is Some(v) {
    props.push(("y1", static_attr(v)))
  }
  if x2 is Some(v) {
    props.push(("x2", static_attr(v)))
  }
  if y2 is Some(v) {
    props.push(("y2", static_attr(v)))
  }
  if stroke is Some(v) {
    props.push(("stroke", static_attr(v)))
  }
  if stroke_width is Some(v) {
    props.push(("stroke-width", static_attr(v)))
  }
  create_svg_element("line", props, [])
}

///|
/// Create an SVG polyline element
pub fn svg_polyline(
  points? : String,
  fill? : String,
  stroke? : String,
  stroke_width? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if points is Some(v) {
    props.push(("points", static_attr(v)))
  }
  if fill is Some(v) {
    props.push(("fill", static_attr(v)))
  }
  if stroke is Some(v) {
    props.push(("stroke", static_attr(v)))
  }
  if stroke_width is Some(v) {
    props.push(("stroke-width", static_attr(v)))
  }
  create_svg_element("polyline", props, [])
}

///|
/// Create an SVG polygon element
pub fn svg_polygon(
  points? : String,
  fill? : String,
  stroke? : String,
  stroke_width? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if points is Some(v) {
    props.push(("points", static_attr(v)))
  }
  if fill is Some(v) {
    props.push(("fill", static_attr(v)))
  }
  if stroke is Some(v) {
    props.push(("stroke", static_attr(v)))
  }
  if stroke_width is Some(v) {
    props.push(("stroke-width", static_attr(v)))
  }
  create_svg_element("polygon", props, [])
}

///|
/// Create an SVG path element
pub fn svg_path(
  d? : String,
  fill? : String,
  stroke? : String,
  stroke_width? : String,
  stroke_linecap? : String,
  stroke_linejoin? : String,
  fill_rule? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if d is Some(v) {
    props.push(("d", static_attr(v)))
  }
  if fill is Some(v) {
    props.push(("fill", static_attr(v)))
  }
  if stroke is Some(v) {
    props.push(("stroke", static_attr(v)))
  }
  if stroke_width is Some(v) {
    props.push(("stroke-width", static_attr(v)))
  }
  if stroke_linecap is Some(v) {
    props.push(("stroke-linecap", static_attr(v)))
  }
  if stroke_linejoin is Some(v) {
    props.push(("stroke-linejoin", static_attr(v)))
  }
  if fill_rule is Some(v) {
    props.push(("fill-rule", static_attr(v)))
  }
  create_svg_element("path", props, [])
}

///|
/// Create an SVG text element
pub fn svg_text(
  x? : String,
  y? : String,
  dx? : String,
  dy? : String,
  text_anchor? : String,
  dominant_baseline? : String,
  fill? : String,
  font_size? : String,
  font_family? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if x is Some(v) {
    props.push(("x", static_attr(v)))
  }
  if y is Some(v) {
    props.push(("y", static_attr(v)))
  }
  if dx is Some(v) {
    props.push(("dx", static_attr(v)))
  }
  if dy is Some(v) {
    props.push(("dy", static_attr(v)))
  }
  if text_anchor is Some(v) {
    props.push(("text-anchor", static_attr(v)))
  }
  if dominant_baseline is Some(v) {
    props.push(("dominant-baseline", static_attr(v)))
  }
  if fill is Some(v) {
    props.push(("fill", static_attr(v)))
  }
  if font_size is Some(v) {
    props.push(("font-size", static_attr(v)))
  }
  if font_family is Some(v) {
    props.push(("font-family", static_attr(v)))
  }
  create_svg_element("text", props, children)
}

///|
/// Create an SVG tspan element
pub fn svg_tspan(
  x? : String,
  y? : String,
  dx? : String,
  dy? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if x is Some(v) {
    props.push(("x", static_attr(v)))
  }
  if y is Some(v) {
    props.push(("y", static_attr(v)))
  }
  if dx is Some(v) {
    props.push(("dx", static_attr(v)))
  }
  if dy is Some(v) {
    props.push(("dy", static_attr(v)))
  }
  create_svg_element("tspan", props, children)
}

///|
/// Create an SVG image element
pub fn svg_image(
  href? : String,
  x? : String,
  y? : String,
  width? : String,
  height? : String,
  preserveAspectRatio? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if href is Some(v) {
    props.push(("href", static_attr(v)))
  }
  if x is Some(v) {
    props.push(("x", static_attr(v)))
  }
  if y is Some(v) {
    props.push(("y", static_attr(v)))
  }
  if width is Some(v) {
    props.push(("width", static_attr(v)))
  }
  if height is Some(v) {
    props.push(("height", static_attr(v)))
  }
  if preserveAspectRatio is Some(v) {
    props.push(("preserveAspectRatio", static_attr(v)))
  }
  create_svg_element("image", props, [])
}

///|
/// Create an SVG clipPath element
pub fn svg_clip_path(
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  create_svg_element("clipPath", props, children)
}

///|
/// Create an SVG mask element
pub fn svg_mask(
  x? : String,
  y? : String,
  width? : String,
  height? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if x is Some(v) {
    props.push(("x", static_attr(v)))
  }
  if y is Some(v) {
    props.push(("y", static_attr(v)))
  }
  if width is Some(v) {
    props.push(("width", static_attr(v)))
  }
  if height is Some(v) {
    props.push(("height", static_attr(v)))
  }
  create_svg_element("mask", props, children)
}

///|
/// Create an SVG linearGradient element
pub fn svg_linear_gradient(
  x1? : String,
  y1? : String,
  x2? : String,
  y2? : String,
  gradientUnits? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if x1 is Some(v) {
    props.push(("x1", static_attr(v)))
  }
  if y1 is Some(v) {
    props.push(("y1", static_attr(v)))
  }
  if x2 is Some(v) {
    props.push(("x2", static_attr(v)))
  }
  if y2 is Some(v) {
    props.push(("y2", static_attr(v)))
  }
  if gradientUnits is Some(v) {
    props.push(("gradientUnits", static_attr(v)))
  }
  create_svg_element("linearGradient", props, children)
}

///|
/// Create an SVG radialGradient element
pub fn svg_radial_gradient(
  cx? : String,
  cy? : String,
  r? : String,
  fx? : String,
  fy? : String,
  gradientUnits? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if cx is Some(v) {
    props.push(("cx", static_attr(v)))
  }
  if cy is Some(v) {
    props.push(("cy", static_attr(v)))
  }
  if r is Some(v) {
    props.push(("r", static_attr(v)))
  }
  if fx is Some(v) {
    props.push(("fx", static_attr(v)))
  }
  if fy is Some(v) {
    props.push(("fy", static_attr(v)))
  }
  if gradientUnits is Some(v) {
    props.push(("gradientUnits", static_attr(v)))
  }
  create_svg_element("radialGradient", props, children)
}

///|
/// Create an SVG stop element for gradients
pub fn svg_stop(
  offset? : String,
  stop_color? : String,
  stop_opacity? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if offset is Some(v) {
    props.push(("offset", static_attr(v)))
  }
  if stop_color is Some(v) {
    props.push(("stop-color", static_attr(v)))
  }
  if stop_opacity is Some(v) {
    props.push(("stop-opacity", static_attr(v)))
  }
  create_svg_element("stop", props, [])
}

///|
/// Create an SVG pattern element
pub fn svg_pattern(
  x? : String,
  y? : String,
  width? : String,
  height? : String,
  patternUnits? : String,
  patternContentUnits? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if x is Some(v) {
    props.push(("x", static_attr(v)))
  }
  if y is Some(v) {
    props.push(("y", static_attr(v)))
  }
  if width is Some(v) {
    props.push(("width", static_attr(v)))
  }
  if height is Some(v) {
    props.push(("height", static_attr(v)))
  }
  if patternUnits is Some(v) {
    props.push(("patternUnits", static_attr(v)))
  }
  if patternContentUnits is Some(v) {
    props.push(("patternContentUnits", static_attr(v)))
  }
  create_svg_element("pattern", props, children)
}

///|
/// Create an SVG filter element
pub fn svg_filter(
  x? : String,
  y? : String,
  width? : String,
  height? : String,
  filterUnits? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if x is Some(v) {
    props.push(("x", static_attr(v)))
  }
  if y is Some(v) {
    props.push(("y", static_attr(v)))
  }
  if width is Some(v) {
    props.push(("width", static_attr(v)))
  }
  if height is Some(v) {
    props.push(("height", static_attr(v)))
  }
  if filterUnits is Some(v) {
    props.push(("filterUnits", static_attr(v)))
  }
  create_svg_element("filter", props, children)
}

///|
/// Create an SVG animate element
pub fn svg_animate(
  attributeName? : String,
  from? : String,
  to? : String,
  dur? : String,
  repeatCount? : String,
  fill_anim? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if attributeName is Some(v) {
    props.push(("attributeName", static_attr(v)))
  }
  if from is Some(v) {
    props.push(("from", static_attr(v)))
  }
  if to is Some(v) {
    props.push(("to", static_attr(v)))
  }
  if dur is Some(v) {
    props.push(("dur", static_attr(v)))
  }
  if repeatCount is Some(v) {
    props.push(("repeatCount", static_attr(v)))
  }
  if fill_anim is Some(v) {
    props.push(("fill", static_attr(v)))
  }
  create_svg_element("animate", props, [])
}

///|
/// Create an SVG animateTransform element
pub fn svg_animate_transform(
  attributeName? : String,
  type_? : String,
  from? : String,
  to? : String,
  dur? : String,
  repeatCount? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if attributeName is Some(v) {
    props.push(("attributeName", static_attr(v)))
  }
  if type_ is Some(v) {
    props.push(("type", static_attr(v)))
  }
  if from is Some(v) {
    props.push(("from", static_attr(v)))
  }
  if to is Some(v) {
    props.push(("to", static_attr(v)))
  }
  if dur is Some(v) {
    props.push(("dur", static_attr(v)))
  }
  if repeatCount is Some(v) {
    props.push(("repeatCount", static_attr(v)))
  }
  create_svg_element("animateTransform", props, [])
}

///|
/// Create an SVG foreignObject element for embedding HTML
pub fn svg_foreign_object(
  x? : String,
  y? : String,
  width? : String,
  height? : String,
  id? : String,
  class? : String,
  style? : String,
  attrs? : Array[(String, @luna.Attr[Unit, String])],
  children : Array[@luna.Node[Unit, String]],
) -> @luna.Node[Unit, String] {
  let props = build_attrs(id, class, style, attrs)
  if x is Some(v) {
    props.push(("x", static_attr(v)))
  }
  if y is Some(v) {
    props.push(("y", static_attr(v)))
  }
  if width is Some(v) {
    props.push(("width", static_attr(v)))
  }
  if height is Some(v) {
    props.push(("height", static_attr(v)))
  }
  create_svg_element("foreignObject", props, children)
}
