// Generated using `moon info`, DON'T EDIT IT
package "mizchi/ui/signals"

// Values
pub fn all(Array[Signal[Bool]]) -> () -> Bool

pub fn any(Array[Signal[Bool]]) -> () -> Bool

pub fn[T] batch(() -> T) -> T

pub fn batch_end() -> Unit

pub fn batch_start() -> Unit

pub fn combine(Signal[Any], Signal[Any], (Any, Any) -> Any) -> () -> Any

pub fn[A, B, R] combine2(Signal[A], Signal[B], (A, B) -> R) -> () -> R

pub fn[A, B, C, R] combine3(Signal[A], Signal[B], Signal[C], (A, B, C) -> R) -> () -> R

pub fn[A, B, C, D, R] combine4(Signal[A], Signal[B], Signal[C], Signal[D], (A, B, C, D) -> R) -> () -> R

pub fn[T] computed(() -> T) -> () -> T

pub fn create_memo(() -> Any) -> () -> Any

pub fn create_signal(Any) -> Signal[Any]

pub fn effect(() -> Unit) -> () -> Unit

pub fn effect_once(() -> Unit) -> Unit

pub fn effect_when(() -> Bool, () -> Unit) -> () -> Unit

pub fn effect_with_cleanup(() -> (() -> Unit)?) -> () -> Unit

pub fn event_handler() -> EventHandler

pub fn[T] flatten(Signal[Signal[T]]) -> () -> T

pub fn get(Signal[Any]) -> Any

pub fn get_current_subscriber() -> EffectRunner?

pub fn has_dynamic_content(Array[(String, VAttr)]) -> Bool

pub fn is_batching() -> Bool

pub fn map(Signal[Any], (Any) -> Any) -> () -> Any

pub fn[T] memo(() -> T) -> () -> T

pub fn new_effect_id() -> Int

pub fn[T] on(Signal[T], (T) -> Unit) -> () -> Unit

pub fn onCleanup(() -> Unit) -> Unit

pub fn[T] on_immediate(Signal[T], (T) -> Unit) -> () -> Unit

pub fn peek(Signal[Any]) -> Any

pub fn[T] previous(Signal[T]) -> () -> T?

pub fn[T] previous_with_initial(Signal[T], T) -> () -> T

pub fn run_untracked(() -> Any) -> Any

pub fn[T] run_with_cleanup_tracking(Array[() -> Unit], () -> T) -> T

pub fn[T] run_with_subscriber(EffectRunner, () -> T) -> T

pub fn schedule_effect(EffectRunner) -> Unit

pub fn[T] select(Signal[Array[T]], Signal[Int]) -> () -> T?

pub fn set(Signal[Any], Any) -> Unit

pub fn set_current_cleanups(Array[() -> Unit]?) -> Array[() -> Unit]?

pub fn[T] signal(T) -> Signal[T]

pub fn subscribe(Signal[Any], (Any) -> Unit) -> () -> Unit

pub fn[T] switch_(Signal[Bool], Signal[T], Signal[T]) -> () -> T

pub fn[T] untracked(() -> T) -> T

pub fn update(Signal[Any], (Any) -> Any) -> Unit

pub fn va(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn valt(String) -> (String, VAttr)

pub fn vattr(String, String) -> (String, VAttr)

pub fn vattr_dyn(String, () -> String) -> (String, VAttr)

pub fn vbr() -> VNode

pub fn vbutton(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn vclass(String) -> (String, VAttr)

pub fn vclass_dyn(() -> String) -> (String, VAttr)

pub fn vcomponent(() -> VNode) -> VNode

pub fn vdisabled(Bool) -> (String, VAttr)

pub fn vdiv(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn vfor(() -> Array[VNode]) -> VNode

pub fn vform(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn vfragment(Array[VNode]) -> VNode

pub fn vh1(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn vh2(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn vh3(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn vhr() -> VNode

pub fn vhref(String) -> (String, VAttr)

pub fn vid(String) -> (String, VAttr)

pub fn vimg(Array[(String, VAttr)]) -> VNode

pub fn vinput(Array[(String, VAttr)]) -> VNode

pub fn vlabel(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn vli(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn vnode(String, Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn vol(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn von_change(EventHandler) -> (String, VAttr)

pub fn von_click(EventHandler) -> (String, VAttr)

pub fn von_input(EventHandler) -> (String, VAttr)

pub fn von_submit(EventHandler) -> (String, VAttr)

pub fn vp(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn vplaceholder(String) -> (String, VAttr)

pub fn vshow(() -> Bool, () -> VNode) -> VNode

pub fn vspan(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn vsrc(String) -> (String, VAttr)

pub fn vstyle(Array[(String, String)]) -> (String, VAttr)

pub fn vstyle_dyn(() -> Array[(String, String)]) -> (String, VAttr)

pub fn vtext(String) -> VNode

pub fn vtext_dyn(() -> String) -> VNode

pub fn[T : Show] vtext_sig(Signal[T]) -> VNode

pub fn vtype(String) -> (String, VAttr)

pub fn vul(Array[(String, VAttr)], Array[VNode]) -> VNode

pub fn vvalue(String) -> (String, VAttr)

pub fn vvalue_dyn(() -> String) -> (String, VAttr)

pub fn[T : Eq] watch(() -> T, (T, T) -> Unit) -> () -> Unit

pub fn[T : Eq] watch_immediate(() -> T, (T, T?) -> Unit) -> () -> Unit

// Errors

// Types and methods
#external
pub type Any

pub struct EffectRunner {
  id : Int
  run : () -> Unit
}

pub struct EventHandler(Unit)
#deprecated
pub fn EventHandler::inner(Self) -> Unit

pub struct Signal[T] {
  mut value : T
  subscribers : Array[EffectRunner]
}
pub fn[T] Signal::clear_subscribers(Self[T]) -> Unit
pub fn[T] Signal::filter(Self[T], (T) -> Bool) -> Self[T?]
pub fn[T, U] Signal::filter_map(Self[T], (T) -> U?) -> Self[U?]
pub fn[T] Signal::get(Self[T]) -> T
pub fn[T, U] Signal::map(Self[T], (T) -> U) -> () -> U
pub fn[T] Signal::new(T) -> Self[T]
pub fn[T] Signal::peek(Self[T]) -> T
pub fn[T] Signal::remove_subscriber(Self[T], Int) -> Unit
pub fn[T] Signal::set(Self[T], T) -> Unit
pub fn[T] Signal::subscriber_count(Self[T]) -> Int
pub fn[T] Signal::to_getter(Self[T]) -> () -> T
pub fn[T] Signal::update(Self[T], (T) -> T) -> Unit

pub enum VAttr {
  VStatic(String)
  VDynamic(() -> String)
  VHandler(EventHandler)
  VStyle(Array[(String, String)])
  VDynamicStyle(() -> Array[(String, String)])
}

pub struct VElement {
  tag : String
  attrs : Array[(String, VAttr)]
  children : Array[VNode]
}

pub enum VNode {
  VElement(VElement)
  VText(String)
  VDynamicText(() -> String)
  VFragment(Array[VNode])
  VShow(condition~ : () -> Bool, child~ : () -> VNode)
  VFor(render~ : () -> Array[VNode])
  VComponent(render~ : () -> VNode)
}

// Type aliases

// Traits

