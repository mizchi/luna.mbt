/*! luna loader v1 - MIT License */
((d, w) => {
  const S = {};
  const loaded = new Set();

  const parseState = async (el) => {
    const attr = el.getAttribute('ln:state');
    if (!attr) return null;
    if (attr.startsWith('#')) {
      const script = d.getElementById(attr.slice(1));
      return script ? JSON.parse(script.textContent) : null;
    }
    try { return JSON.parse(attr); } catch { return null; }
  };

  const hydrate = async (el) => {
    const id = el.getAttribute('ln:id');
    if (!id || loaded.has(id)) return;
    loaded.add(id);
    const url = el.getAttribute('ln:url');
    if (!url) return;
    const state = await parseState(el);
    S[id] = state;
    try {
      const mod = await import(url);
      const exportName = el.getAttribute('ln:export');
      const fn = exportName ? mod[exportName] : (mod.hydrate || mod.default);
      if (fn) fn(el, state, id);
    } catch (e) {
      console.error(`[ln-loader] Failed to hydrate ${id}:`, e);
    }
  };

  const setupTrigger = (el) => {
    const trigger = el.getAttribute('ln:trigger') || 'load';
    if (trigger === 'load') {
      if (d.readyState === 'loading') {
        d.addEventListener('DOMContentLoaded', () => hydrate(el), { once: true });
      } else { hydrate(el); }
    } else if (trigger === 'idle') {
      if ('requestIdleCallback' in w) { requestIdleCallback(() => hydrate(el)); }
      else { setTimeout(() => hydrate(el), 200); }
    } else if (trigger === 'visible') {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => { if (entry.isIntersecting) { observer.disconnect(); hydrate(el); } });
      }, { rootMargin: '50px' });
      observer.observe(el);
    } else if (trigger.startsWith('media:')) {
      const query = trigger.slice(6);
      const mql = w.matchMedia(query);
      const check = () => { if (mql.matches) { mql.removeEventListener('change', check); hydrate(el); } };
      if (mql.matches) { hydrate(el); } else { mql.addEventListener('change', check); }
    }
  };

  const scan = () => { d.querySelectorAll('[ln\\:id]').forEach(setupTrigger); };

  d.querySelectorAll('script[type="ln/json"]').forEach(s => { if (s.id) S[s.id] = JSON.parse(s.textContent); });

  if (d.readyState === 'loading') { d.addEventListener('DOMContentLoaded', scan, { once: true }); }
  else { scan(); }

  const mo = new MutationObserver((mutations) => {
    mutations.forEach(m => { m.addedNodes.forEach(node => { if (node.nodeType === 1 && node.hasAttribute('ln:id')) setupTrigger(node); }); });
  });
  mo.observe(d.body || d.documentElement, { childList: true, subtree: true });

  w.__LN_STATE__ = S;
  w.__LN_HYDRATE__ = hydrate;
  w.__LN_SCAN__ = scan;
})(document, window);
